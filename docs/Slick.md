
# Slick для начинающих

## Использование в проекте

### Поддерживаемые СУБД

На момент написания руководства __Slick__ поддерживает [следующие СУБД](http://slick.lightbend.com/doc/3.2.1/supported-databases.html):

* DB2
* Derby / JavaDB
* H2
* HSQLDB (HyperSQL)
* Microsoft SQL Server
* MySQL
* Oracle
* PostgreSQL
* SQLite

В этом руководстве мы будем использовать СУБД __H2__.

### Настройка SBT

Для того, чтобы классы Slick были доступны в вашем проекте, нужно добавить его в качестве зависимости в
конфигурационный файл сборки SBT. Для простых проектов его имя обычно __build.sbt__. Зависимость от Slick,
как и все остальные, добавляется в настройку __libraryDependencies__:

```sbtshell
libraryDependencies += "com.typesafe.slick" %% "slick" % "3.2.1"
```

Также нужно подключить стандартный драйвер для работы с выбранной базой данных.
Для H2 добавляем строчку

```sbtshell
libraryDependencies += "com.h2database" % "h2" % "1.4.196"
```

При следующем вызове `sbt update` (или нажатия `Refresh project` в __Idea__) библиотеки скачаются из репозитория и будут доступны для использования.

### Настройка соединения 

Настройку соединения с базой данных рекомендовано производить в общем для всех инструментов __Typesafe/Lightbend__ файле `application.conf`:

```
h2mem1 = {
  url = "jdbc:h2:mem:test1"
  driver = org.h2.Driver
  connectionPool = disabled
  keepAliveConnection = true
}
```

Как видно, в данном случае в файл добавлена настройка для одной базы данных, доступной в программе под именем __h2mem1__,
использующей драйвер __H2__ и располагающейся в памяти под именем __test1__.

Есть и другие варианты настройки, которые мы здесь не рассматриваем.

## Простой пример

Перейдем к коду на __Scala__. Определим в программе единственный самый простой объект в файле `Main.scala`:

```scala
package org.slickorial

object Main extends App {
  
}
```

Во-первых, все операции с базой данных Slick выполняет асинхронно.
Это означает, что ему нужно иметь доступ в пределах области видимости к контексту исполнения (__ExecutionContext__),
в рамках которого будут планироваться асинхронные вызовы.
Как обычно, для простых случаев достаточно встроенного в стандартную библиотеку глобального контекста:

```scala
import scala.concurrent.ExecutionContext.Implicits.global
```

Во-вторых, для доступа к специфичным для выбранной СУБД реализациям API нужно импортировать соответствующий этой СУБД объект:

```scala
import slick.jdbc.H2Profile.api._
```

### Создание класса таблицы

Для работы с каждой таблицей БД нужно создать специальный класс, наследуемый от класса __Table__.
Объект такого класса представляет собой строку, и напрямую он обычно не создается,
но как мы увидим ниже, им параметризуется другой класс __TableQuery__,
который уже и предоставляет API для работы с конкретной коллекцией-таблицей.

Самый простой сценарий предполагает, что в качестве строк таблицы мы будем работать напрямую с кортежами данных, а не с объектами
предметной области. Допустим, мы делаем приложение &mdash; справочник футбольного фаната.
Придумаем две простых таблицы &mdash; __Teams__ и __Players__, между которыми установлена связь 1 к N (псевдокод):

```
TEAMS:
    int    id
    String name
    String country
    
PLAYERS:
    int    id
    int    team_id
    String name
``` 

Соответствующие типы кортежей Scala будут `(Int, String, String)` и `(Int, Int, String)`.

Класс `Table` &mdash; обобщенный (_generic_), поэтому чтобы создать класс конкретной таблицы, нужно наследоваться
от соответствующей его специализации. В случае таблицы Teams это будет `Table[(Int, String, String)]`:

```scala
class TeamsTable(tag: Tag) extends Table[(Int, String, String)](tag, "TEAMS")
```

Вторым параметром в конструкторе `Table` указано имя соответствующей таблицы в базе данных.

### Поднятые (lifted) значения

Поднятое значение &mdash; это значение, взятое в контексте таблицы базы данных. Например, поднятый аналог
значения какого-то типа &mdash; это колонка этого типа. 

### Структура класса таблицы

Класс `Table` не только обобщенный, но и абстрактный. Он требует обязательной реализации в потомках метода
с именем `*`, возвращающего описание структуры строки таблицы в терминах колонок:

```scala
override def * = (column[Int]("ID"), column[String]("NAME"), column[String]("COUNTRY"))
```

Обычно полезно каждую колонку хранить в виде отдельного метода, чтобы вызывать его у строк таблицы
(не забываем, что экземпляр класса-потомка `Table` &mdash; это строка):

```scala
def id = column[Int]("ID")
```

Тогда окончательная версия нашего класса `TeamsTable` будет выглядеть так:

```scala
class TeamsTable(tag: Tag) extends Table[(Int, String, String)](tag, "TEAMS") {
  def id = column[Int]("ID")
  def name = column[String]("NAME")
  def country = column[String]("COUNTRY")
  override def * = (id, name, country)
}
```

Для непосредственной работы с таблицей используется значение типа `TableQuery`, параметризованного классом таблицы:

```scala
val teams = TableQuery[TeamsTable]
```

### Отправка запроса в базу данных

Операции с базой данных производятся через объект __Database__.
Соответствующая фабрика может сконструировать для нас объект по имени настройки подключения: 

```scala
 val db = Database.forConfig("h2mem1")
```

Первый сценарий использования этого объекта - путем вызова его метода `run()`. Аргументом в этот
метод передается значение типа `DBIOAction`, представляющее собой действие над базой данных.
Действие может быть как простым, так и составным. Метод `run()` возвращает значение типа `Future`,
которое в свою очередь при выполнении содержит значение, зависящее от конкретного действия.
 
Сначала рассмотрим некоторые простые действия.

```scala
db.run(teams.schema.create)
```

Метод `create` у свойства `schema` возвращает действие, создающее таблицу с заданной структурой
в базе данных (с помощью вызовов DDL).
